package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type ListType struct {
	Package                string
	Header                 string // This is autogenerated from the Type
	OptionalImport         string
	Type                   string
	ElemType               string
	CType                  string
	PrimitiveType          bool
	OptDefaultElemType     string
	OptTestDefaultListData string // e.g. "{1, 2, 3}". S
	OptTestVal1            string // e.g. "42"
	OptTestOtherListData   string // e.g. "{99}"
	CElemTypeConstructor   string // only needed for non PrimitiveType
}

func toPkgName(typeName string) string {
	if typeName == "" {
		return ""
	}
	runes := []rune(typeName)
	i := 1
	for ; i < len(runes); i++ {
		if runes[i] >= 'A' && runes[i] <= 'Z' {
			break
		}
	}
	return strings.ToLower(string(runes[:i])) + string(runes[i:])
}

func main() {
	// Edit the types to add more generated types to the system
	types := []ListType{
		{Type: "ListInt", ElemType: "int32", CType: "int", OptDefaultElemType: "0", OptTestDefaultListData: "{0,1}", OptTestVal1: "4", OptTestOtherListData: "{3}", PrimitiveType: true},
		{Type: "ListFloat", ElemType: "float32", CType: "float", OptDefaultElemType: "0.0", OptTestDefaultListData: "{1.1,2.2}", OptTestVal1: "3.3", OptTestOtherListData: "{1.0}", PrimitiveType: true},
		{Type: "ListDouble", ElemType: "float64", CType: "double", OptDefaultElemType: "0.0", OptTestDefaultListData: "{1.1,2.2}", OptTestVal1: "3.3", OptTestOtherListData: "{1.0}", PrimitiveType: true},
		{Type: "ListBool", ElemType: "bool", CType: "bool", OptDefaultElemType: "false", OptTestDefaultListData: "{true,false}", OptTestVal1: "true", OptTestOtherListData: "{true}", PrimitiveType: true},
		{Type: "ListSizeT", ElemType: "uint64", CType: "size_t", OptDefaultElemType: "0", OptTestDefaultListData: "{0,1}", OptTestVal1: "4", OptTestOtherListData: "{3}", PrimitiveType: true},
		{Type: "ListConnection", ElemType: "*connection.Handle", CType: "ConnectionHandle", OptionalImport: `"github.com/falcon-autotuning/falcon-core-libs/go/falcon-core/physics/deviceStructures/connection"`, PrimitiveType: false, CElemTypeConstructor: "connection.FromCAPI"},
		{Type: "ListImpedance", ElemType: "*impedance.Handle", CType: "ImpedanceHandle", OptionalImport: `"github.com/falcon-autotuning/falcon-core-libs/go/falcon-core/physics/deviceStructures/impedance"`, PrimitiveType: false, CElemTypeConstructor: "impedance.FromCAPI"},
		// Add more types here...
	}

	// Set Header automatically for each type
	for i := range types {
		types[i].Header = types[i].Type + "_c_api.h"
	}

	// Parse as separate templates, no {{define ...}} in files
	wrapperTmpl := template.Must(template.ParseFiles("generic/list/list_wrapper.tmpl"))
	testTmpl := template.Must(template.ParseFiles("generic/list/list_test_wrapper.tmpl"))

	manifest, err := os.Create("list_handles_manifest.txt")
	if err != nil {
		panic(err)
	}
	defer manifest.Close()
	for _, t := range types {
		pkg := toPkgName(t.Type)
		t.Package = pkg
		dir := filepath.Join("generic", pkg)
		if err := os.MkdirAll(dir, 0o755); err != nil {
			panic(err)
		}
		// Implementation file
		implFile := filepath.Join(dir, pkg+".go")
		f, err := os.Create(implFile)
		if err != nil {
			panic(err)
		}
		if err := wrapperTmpl.Execute(f, t); err != nil {
			panic(err)
		}
		f.Close()
		fmt.Fprintln(manifest, implFile)

		// Test file
		testFile := filepath.Join(dir, pkg+"_test.go")
		tf, err := os.Create(testFile)
		if err != nil {
			panic(err)
		}
		if err := testTmpl.Execute(tf, t); err != nil {
			panic(err)
		}
		tf.Close()
		fmt.Fprintln(manifest, testFile)
	}
}
