// Code generated by go generate; DO NOT EDIT.
package {{.Package}}

import (
	"testing"

	"github.com/falcon-autotuning/falcon-core-libs/go/falcon-core/generic/list{{.GoArrayType}}"
  "github.com/falcon-autotuning/falcon-core-libs/go/falcon-core/math/arrays/{{.GoArrayType}}"
)

func eqSlice(a, b []*{{.GoArrayType}}.Handle) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if (a[i] == nil) != (b[i] == nil) {
			return false
		}
		if a[i] != nil {
			eq, err := a[i].Equal(b[i])
			if err != nil || !eq {
				return false
			}
		}
	}
	return true
}

func fixtureListData() []*{{.GoArrayType}}.Handle {
	return defaultListData
}

func Test{{.Type}}_NewFromListAndPushBack(t *testing.T) {
	list, err := list{{.GoArrayType}}.New(defaultListData)
	if err != nil {
		t.Fatalf("New list failed: %v", err)
	}
	defer list.Close()
	l, err := NewFromList(list)
	if err != nil {
		t.Fatalf("NewFromList failed: %v", err)
	}
	defer l.Close()
	if sz, err := l.Size(); err != nil || sz != len(defaultListData) {
		t.Fatalf("Expected size %d, got %d, err: %v", len(defaultListData), sz, err)
	}
	for i, v := range defaultListData {
		if err := l.PushBack(v); err != nil {
			t.Fatalf("PushBack failed at %d: %v", i, err)
		}
	}
	if sz, err := l.Size(); err != nil || sz != 2*len(defaultListData) {
		t.Errorf("Expected size %d, got %d, err: %v", 2*len(defaultListData), sz, err)
	}
}

func Test{{.Type}}_ArraysLabelsAndIsMethods(t *testing.T) {
	list, err := list{{.GoArrayType}}.New(defaultListData)
	if err != nil {
		t.Fatalf("New list failed: %v", err)
	}
	defer list.Close()
	l, err := NewFromList(list)
	if err != nil {
		t.Fatalf("NewFromList failed: %v", err)
	}
	defer l.Close()
	arrays, err := l.Arrays()
	if err != nil {
		t.Fatalf("Arrays() failed: %v", err)
	}
	if arrays == nil {
		t.Errorf("Arrays() returned nil")
	}
	labels, err := l.Labels()
	if err != nil {
		t.Fatalf("Labels() failed: %v", err)
	}
	if labels == nil {
		t.Errorf("Labels() returned nil")
	}
	_, err = l.IsControlArrays()
	if err != nil {
		t.Errorf("IsControlArrays() failed: %v", err)
	}
	_, err = l.IsMeasuredArrays()
	if err != nil {
		t.Errorf("IsMeasuredArrays() failed: %v", err)
	}
}

func Test{{.Type}}_EraseAtAndClear(t *testing.T) {
	list, err := list{{.GoArrayType}}.New(defaultListData)
	if err != nil {
		t.Fatalf("New list failed: %v", err)
	}
	defer list.Close()
	l, err := NewFromList(list)
	if err != nil {
		t.Fatalf("NewFromList failed: %v", err)
	}
	defer l.Close()
	if err := l.EraseAt(1); err != nil {
		t.Fatalf("EraseAt failed: %v", err)
	}
	if err := l.Clear(); err != nil {
		t.Fatalf("Clear failed: %v", err)
	}
	empty, err := l.Empty()
	if err != nil || !empty {
		t.Errorf("Expected list to be empty after Clear, err: %v", err)
	}
}

func Test{{.Type}}_AtContainsIndex(t *testing.T) {
	list, err := list{{.GoArrayType}}.New(defaultListData)
	if err != nil {
		t.Fatalf("New list failed: %v", err)
	}
	defer list.Close()
	l, err := NewFromList(list)
	if err != nil {
		t.Fatalf("NewFromList failed: %v", err)
	}
	defer l.Close()
	val, err := l.At(0)
	if err != nil {
		t.Fatalf("At(0) failed: %v", err)
	}
	ok, err := l.Contains(val)
	if err != nil || !ok {
		t.Errorf("Contains(val) = %v, want true, err: %v", ok, err)
	}
	idx, err := l.Index(val)
	if err != nil || idx != 0 {
		t.Errorf("Index(val) = %v, want 0, err: %v", idx, err)
	}
}

func Test{{.Type}}_IntersectionEqualNotEqual(t *testing.T) {
	list, err := list{{.GoArrayType}}.New(defaultListData)
	if err != nil {
		t.Fatalf("New list failed: %v", err)
	}
	defer list.Close()
	a, err := NewFromList(list)
	if err != nil {
		t.Fatalf("NewFromList failed: %v", err)
	}
	defer a.Close()
	b, err := NewFromList(list)
	if err != nil {
		t.Fatalf("NewFromList (b) failed: %v", err)
	}
	defer b.Close()
	inter, err := a.Intersection(b)
	if err != nil {
		t.Fatalf("Intersection failed: %v", err)
	}
	defer inter.Close()
	eq, err := a.Equal(b)
	if err != nil || !eq {
		t.Errorf("Expected Equal true, got %v, err: %v", eq, err)
	}
	otherList, err := list{{.GoArrayType}}.New(otherListData)
	if err != nil {
		t.Fatalf("New otherList failed: %v", err)
	}
	defer otherList.Close()
	other, err := NewFromList(otherList)
	if err != nil {
		t.Fatalf("NewFromList (other) failed: %v", err)
	}
	neq, err := a.NotEqual(other)
	if err != nil || !neq {
		t.Errorf("Expected NotEqual true, got %v, err: %v", neq, err)
	}
}

func Test{{.Type}}_ToJSONAndFromJSON(t *testing.T) {
	list, err := list{{.GoArrayType}}.New(defaultListData)
	if err != nil {
		t.Fatalf("New list failed: %v", err)
	}
	defer list.Close()
	l, err := NewFromList(list)
	if err != nil {
		t.Fatalf("NewFromList failed: %v", err)
	}
	defer l.Close()
	jsonStr, err := l.ToJSON()
	if err != nil {
		t.Fatalf("ToJSON failed: %v", err)
	}
	l2, err := FromJSON(jsonStr)
	if err != nil {
		t.Fatalf("FromJSON failed: %v", err)
	}
	defer l2.Close()
	eq, err := l.Equal(l2)
	if err != nil || !eq {
		t.Errorf("ToJSON/FromJSON roundtrip not equal: %v, err: %v", eq, err)
	}
}

func Test{{.Type}}_CAPIHandle(t *testing.T) {
	list, err := list{{.GoArrayType}}.New(defaultListData)
	if err != nil {
		t.Fatalf("New list failed: %v", err)
	}
	defer list.Close()
	l, err := NewFromList(list)
	if err != nil {
		t.Fatalf("NewFromList failed: %v", err)
	}
	defer l.Close()
	ptr, err := l.CAPIHandle()
	if err != nil {
		t.Errorf("CAPIHandle failed to access capi")
	}
	if ptr == nil {
		t.Errorf("CAPIHandle returned nil")
	}
}

func Test{{.Type}}_FromCAPI(t *testing.T) {
	h, err := FromCAPI(nil)
	if err == nil || h != nil {
		t.Errorf("FromCAPI(nil) should error and return nil")
	}
}

func Test{{.Type}}_CloseTwice(t *testing.T) {
	list, err := list{{.GoArrayType}}.New(defaultListData)
	if err != nil {
		t.Fatalf("New list failed: %v", err)
	}
	defer list.Close()
	l, err := NewFromList(list)
	if err != nil {
		t.Fatalf("NewFromList failed: %v", err)
	}
	err = l.Close()
	if err != nil {
		t.Errorf("First close should succeed, got %v", err)
	}
	err = l.Close()
	if err == nil {
		t.Errorf("Second close should error")
	}
}
