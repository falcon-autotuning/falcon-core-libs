// Code generated by go generate; DO NOT EDIT.
package pairinterpretationcontextquantity

import (
	"testing"
	
	
	"github.com/falcon-autotuning/falcon-core-libs/go/falcon-core/autotuner-interfaces/interpretations/interpretationcontext"
	"github.com/falcon-autotuning/falcon-core-libs/go/falcon-core/math/quantity"
)

var (
	defaultFirst  = defaultInterpretationContext
	defaultSecond = defaultquantity
	otherFirst    = otherInterpretationContext
	otherSecond   = otherquantity
)

func TestPairInterpretationContextQuantity_NewAndAccessors(t *testing.T) {
	p, err := New(defaultFirst, defaultSecond)
	if err != nil {
		t.Fatalf("New failed: %v", err)
	}
	defer p.Close()

	first, err := p.First()
	if err != nil {
		t.Fatalf("First() error: %v", err)
	}
	if !pairFirstEqual(first, defaultFirst) {
		t.Errorf("First() = %v, want %v", first, defaultFirst)
	}

	second, err := p.Second()
	if err != nil {
		t.Fatalf("Second() error: %v", err)
	}
	if !pairSecondEqual(second, defaultSecond) {
		t.Errorf("Second() = %v, want %v", second, defaultSecond)
	}
}

func TestPairInterpretationContextQuantity_EqualAndNotEqual(t *testing.T) {
	p1, err := New(defaultFirst, defaultSecond)
	if err != nil {
		t.Fatalf("New failed: %v", err)
	}
	defer p1.Close()
	p2, err := New(defaultFirst, defaultSecond)
	if err != nil {
		t.Fatalf("New failed: %v", err)
	}
	defer p2.Close()
	eq, err := p1.Equal(p2)
	if err != nil || !eq {
		t.Errorf("Equal = %v, want true, err: %v", eq, err)
	}
	neq, err := p1.NotEqual(p2)
	if err != nil || neq {
		t.Errorf("NotEqual = %v, want false, err: %v", neq, err)
	}
	p3, err := New(otherFirst, otherSecond)
	if err != nil {
		t.Fatalf("New failed: %v", err)
	}
	defer p3.Close()
	eq2, err := p1.Equal(p3)
	if err != nil {
		t.Errorf("Equal (other) error: %v", err)
	}
	if eq2 {
		t.Errorf("Equal (other) = true, want false")
	}
	neq2, err := p1.NotEqual(p3)
	if err != nil {
		t.Errorf("NotEqual (other) error: %v", err)
	}
	if !neq2 {
		t.Errorf("NotEqual (other) = false, want true")
	}
}

func TestPairInterpretationContextQuantity_ToJSONAndFromJSON(t *testing.T) {
	p, err := New(defaultFirst, defaultSecond)
	if err != nil {
		t.Fatalf("New failed: %v", err)
	}
	defer p.Close()
	jsonStr, err := p.ToJSON()
	if err != nil {
		t.Fatalf("ToJSON failed: %v", err)
	}
	p2, err := FromJSON(jsonStr)
	if err != nil {
		t.Fatalf("FromJSON failed: %v", err)
	}
	defer p2.Close()
	eq, err := p.Equal(p2)
	if err != nil || !eq {
		t.Errorf("ToJSON/FromJSON roundtrip not equal: %v, err: %v", eq, err)
	}
}

func TestPairInterpretationContextQuantity_CAPIHandle(t *testing.T) {
	p, err := New(defaultFirst, defaultSecond)
	if err != nil {
		t.Fatalf("New failed: %v", err)
	}
	defer p.Close()
	ptr, err := p.CAPIHandle()
	if err != nil {
		t.Errorf("CAPIHandle failed to access capi")
	}
	if ptr == nil {
		t.Errorf("CAPIHandle returned nil")
	}
}

func TestPairInterpretationContextQuantity_FromCAPI(t *testing.T) {
	h, err := FromCAPI(nil)
	if err == nil || h != nil {
		t.Errorf("FromCAPI(nil) should error and return nil")
	}
}

func TestPairInterpretationContextQuantity_CloseTwice(t *testing.T) {
	p, err := New(defaultFirst, defaultSecond)
	if err != nil {
		t.Fatalf("New failed: %v", err)
	}
	err = p.Close()
	if err != nil {
		t.Errorf("First close should succeed, got %v", err)
	}
	err = p.Close()
	if err == nil {
		t.Errorf("Second close should error")
	}
}

// Helper functions for equality (primitive/non-primitive)
func pairFirstEqual(a, b *interpretationcontext.Handle) bool {
	
	eq, err := a.Equal(b)
	return err == nil && eq
	
}
func pairSecondEqual(a, b *quantity.Handle) bool {
	
	eq, err := a.Equal(b)
	return err == nil && eq
	
}
