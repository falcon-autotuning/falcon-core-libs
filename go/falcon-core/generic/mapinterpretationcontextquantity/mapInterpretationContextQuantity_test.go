// Code generated by go generate; DO NOT EDIT.
package mapinterpretationcontextquantity

import (
	"testing"
	
	
	"github.com/falcon-autotuning/falcon-core-libs/go/falcon-core/math/quantity"
)

var (
	defaultKey   = firstInterpretationContext
	defaultValue = firstQuantity
	otherKey     = secondInterpretationContext
	otherValue   = secondQuantity
)

func TestMapInterpretationContextQuantity_NewEmptyAndBasicOps(t *testing.T) {
	m, err := NewEmpty()
	if err != nil {
		t.Fatalf("NewEmpty failed: %v", err)
	}
	defer m.Close()
	sz, err := m.Size()
	if err != nil {
		t.Fatalf("Size() error: %v", err)
	}
	if sz != 0 {
		t.Errorf("Size() = %v, want 0", sz)
	}
	empty, err := m.Empty()
	if err != nil {
		t.Fatalf("Empty() error: %v", err)
	}
	if !empty {
		t.Errorf("Empty() = false, want true")
	}
}

func TestMapInterpretationContextQuantity_InsertAndAt(t *testing.T) {
	m, err := NewEmpty()
	if err != nil {
		t.Fatalf("NewEmpty failed: %v", err)
	}
	defer m.Close()
	if err := m.Insert(defaultKey, defaultValue); err != nil {
		t.Fatalf("Insert error: %v", err)
	}
	val, err := m.At(defaultKey)
	if err != nil {
		t.Fatalf("At error: %v", err)
	}
	if !mapValueEqual(val, defaultValue) {
		t.Errorf("At() = %v, want %v", val, defaultValue)
	}
}

func TestMapInterpretationContextQuantity_InsertOrAssign(t *testing.T) {
	m, err := NewEmpty()
	if err != nil {
		t.Fatalf("NewEmpty failed: %v", err)
	}
	defer m.Close()
	if err := m.InsertOrAssign(defaultKey, defaultValue); err != nil {
		t.Fatalf("InsertOrAssign error: %v", err)
	}
	if err := m.InsertOrAssign(defaultKey, otherValue); err != nil {
		t.Fatalf("InsertOrAssign (update) error: %v", err)
	}
	val, err := m.At(defaultKey)
	if err != nil {
		t.Fatalf("At error: %v", err)
	}
	if !mapValueEqual(val, otherValue) {
		t.Errorf("At() after update = %v, want %v", val, otherValue)
	}
}

func TestMapInterpretationContextQuantity_EraseAndClear(t *testing.T) {
	m, err := NewEmpty()
	if err != nil {
		t.Fatalf("NewEmpty failed: %v", err)
	}
	defer m.Close()
	m.Insert(defaultKey, defaultValue)
	m.Insert(otherKey, otherValue)
	if err := m.Erase(defaultKey); err != nil {
		t.Fatalf("Erase error: %v", err)
	}
	ok, err := m.Contains(defaultKey)
	if err != nil {
		t.Fatalf("Contains error: %v", err)
	}
	if ok {
		t.Errorf("Contains() after erase = true, want false")
	}
	if err := m.Clear(); err != nil {
		t.Fatalf("Clear error: %v", err)
	}
	sz, _ := m.Size()
	if sz != 0 {
		t.Errorf("Size() after Clear = %v, want 0", sz)
	}
}

func TestMapInterpretationContextQuantity_Contains(t *testing.T) {
	m, err := NewEmpty()
	if err != nil {
		t.Fatalf("NewEmpty failed: %v", err)
	}
	defer m.Close()
	m.Insert(defaultKey, defaultValue)
	ok, err := m.Contains(defaultKey)
	if err != nil {
		t.Fatalf("Contains error: %v", err)
	}
	if !ok {
		t.Errorf("Contains() = false, want true")
	}
	ok, err = m.Contains(otherKey)
	if err != nil {
		t.Fatalf("Contains(other) error: %v", err)
	}
	if ok {
		t.Errorf("Contains(other) = true, want false")
	}
}

func TestMapInterpretationContextQuantity_KeysValuesItems(t *testing.T) {
	m, err := NewEmpty()
	if err != nil {
		t.Fatalf("NewEmpty failed: %v", err)
	}
	defer m.Close()
	m.Insert(defaultKey, defaultValue)
	m.Insert(otherKey, otherValue)
	keys, err := m.Keys()
	if err != nil {
		t.Fatalf("Keys error: %v", err)
	}
	defer keys.Close()
	values, err := m.Values()
	if err != nil {
		t.Fatalf("Values error: %v", err)
	}
	defer values.Close()
	items, err := m.Items()
	if err != nil {
		t.Fatalf("Items error: %v", err)
	}
	defer items.Close()
	// Optionally check contents if needed
}

func TestMapInterpretationContextQuantity_EqualAndNotEqual(t *testing.T) {
	m1, err := NewEmpty()
	if err != nil {
		t.Fatalf("NewEmpty failed: %v", err)
	}
	defer m1.Close()
	m2, err := NewEmpty()
	if err != nil {
		t.Fatalf("NewEmpty failed: %v", err)
	}
	defer m2.Close()
	m1.Insert(defaultKey, defaultValue)
	m2.Insert(defaultKey, defaultValue)
	eq, err := m1.Equal(m2)
	if err != nil || !eq {
		t.Errorf("Equal = %v, want true, err: %v", eq, err)
	}
	neq, err := m1.NotEqual(m2)
	if err != nil || neq {
		t.Errorf("NotEqual = %v, want false, err: %v", neq, err)
	}
	m2.Insert(otherKey, otherValue)
	eq2, err := m1.Equal(m2)
	if err != nil {
		t.Errorf("Equal (other) error: %v", err)
	}
	if eq2 {
		t.Errorf("Equal (other) = true, want false")
	}
	neq2, err := m1.NotEqual(m2)
	if err != nil {
		t.Errorf("NotEqual (other) error: %v", err)
	}
	if !neq2 {
		t.Errorf("NotEqual (other) = false, want true")
	}
}

func TestMapInterpretationContextQuantity_ToJSONAndFromJSON(t *testing.T) {
	m, err := NewEmpty()
	if err != nil {
		t.Fatalf("NewEmpty failed: %v", err)
	}
	defer m.Close()
	m.Insert(defaultKey, defaultValue)
	jsonStr, err := m.ToJSON()
	if err != nil {
		t.Fatalf("ToJSON failed: %v", err)
	}
	m2, err := FromJSON(jsonStr)
	if err != nil {
		t.Fatalf("FromJSON failed: %v", err)
	}
	defer m2.Close()
	eq, err := m.Equal(m2)
	if err != nil || !eq {
		t.Errorf("ToJSON/FromJSON roundtrip not equal: %v, err: %v", eq, err)
	}
}

func TestMapInterpretationContextQuantity_CAPIHandle(t *testing.T) {
	m, err := NewEmpty()
	if err != nil {
		t.Fatalf("NewEmpty failed: %v", err)
	}
	defer m.Close()
	ptr, err := m.CAPIHandle()
	if err != nil {
		t.Errorf("CAPIHandle failed to access capi")
	}
	if ptr == nil {
		t.Errorf("CAPIHandle returned nil")
	}
}

func TestMapInterpretationContextQuantity_FromCAPI(t *testing.T) {
	h, err := FromCAPI(nil)
	if err == nil || h != nil {
		t.Errorf("FromCAPI(nil) should error and return nil")
	}
}

func TestMapInterpretationContextQuantity_CloseTwice(t *testing.T) {
	m, err := NewEmpty()
	if err != nil {
		t.Fatalf("NewEmpty failed: %v", err)
	}
	err = m.Close()
	if err != nil {
		t.Errorf("First close should succeed, got %v", err)
	}
	err = m.Close()
	if err == nil {
		t.Errorf("Second close should error")
	}
}

// Helper for value equality (primitive/non-primitive)
func mapValueEqual(a, b *quantity.Handle) bool {
	
	eq, err := a.Equal(b)
	return err == nil && eq
	
}
