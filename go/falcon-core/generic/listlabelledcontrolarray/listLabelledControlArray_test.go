// Code generated by go generate; DO NOT EDIT.
package listlabelledcontrolarray
import (

	"testing"
	"github.com/falcon-autotuning/falcon-core-libs/go/falcon-core/math/arrays/labelledcontrolarray"
)

// eqSlice compares two slices of *labelledcontrolarray.Handle pointers by dereferencing and calling Equal.
func eqSlice(a, b []*labelledcontrolarray.Handle) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if (a[i] == nil) != (b[i] == nil) {
			return false
		}
		if a[i] != nil {
			equality, err := a[i].Equal(b[i])
			if err != nil {
				return false
			}
			if !equality {
				return false
			}
		}
	}
	return true
}

func fixtureListData() []*labelledcontrolarray.Handle {
	return defaultListData
}
func TestListLabelledControlArray_NewEmptyAndPushBack(t *testing.T) {
	l, err := NewEmpty()
	if err != nil {
		t.Fatalf("NewEmpty failed: %v", err)
	}
	defer l.Close()
	if sz, err := l.Size(); err != nil || sz != 0 {
		t.Fatalf("Expected size 0, got %d, err: %v", sz, err)
	}
	for i, v := range fixtureListData() {
		if err := l.PushBack(v); err != nil {
			t.Fatalf("PushBack failed at %d: %v", i, err)
		}
	}
	if sz, err := l.Size(); err != nil || sz != len(fixtureListData()) {
		t.Errorf("Expected size %d, got %d, err: %v", len(fixtureListData()), sz, err)
	}
}

func TestListLabelledControlArray_NewFromSliceAndItems(t *testing.T) {
	data := fixtureListData()
	l4, err := New(data)
	if err != nil {
		t.Fatalf("New from slice failed: %v", err)
	}
	if l4 == nil {
		t.Fatalf("New is empty")
	}
	defer l4.Close()
	items, err := l4.Items()
	if err != nil {
		t.Fatalf("Items failed: %v", err)
	}
	if !eqSlice(items, data) {
		t.Errorf("Expected %v, got %v", data, items)
	}
}
func TestListLabelledControlArray_EraseAtAndClear(t *testing.T) {
	l5, err := New(fixtureListData())
	if err != nil {
		t.Fatalf("New for erase/clear failed: %v", err)
	}
	defer l5.Close()
	if err := l5.EraseAt(1); err != nil {
		t.Fatalf("EraseAt failed: %v", err)
	}
	items, err := l5.Items()
	if err != nil {
		t.Fatalf("Items after erase failed: %v", err)
	}
	data := append(fixtureListData()[:1], fixtureListData()[2:]...)
	if !eqSlice(items, data) {
		t.Errorf("Expected %v, got %v", data, items)
	}
	if err := l5.Clear(); err != nil {
		t.Fatalf("Clear failed: %v", err)
	}
	if empty, err := l5.Empty(); err != nil || !empty {
		t.Errorf("Expected list to be empty after Clear, err: %v", err)
	}
}
func TestListLabelledControlArray_IntersectionEqualNotEqual(t *testing.T) {
	a, err := New(fixtureListData())
	if err != nil {
		t.Fatalf("New for intersection failed: %v", err)
	}
	defer a.Close()
	b, err := New(fixtureListData())
	if err != nil {
		t.Fatalf("New for intersection (b) failed: %v", err)
	}
	defer b.Close()
	inter, err := a.Intersection(b)
	if err != nil {
		t.Fatalf("Intersection failed: %v", err)
	}
	defer inter.Close()
	items, err := inter.Items()
	if err != nil {
		t.Fatalf("Items after intersection failed: %v", err)
	}
	data := fixtureListData()
	if !eqSlice(items, data) {
		t.Errorf("Expected %v, got %v", data, items)
	}
	eq, err := a.Equal(b)
	if err != nil || !eq {
		t.Errorf("Expected Equal true, got %v, err: %v", eq, err)
	}
	other, err := New(otherListData)
	if err != nil {
		t.Fatalf("New for NotEqual failed: %v", err)
	}
	neq, err := a.NotEqual(other)
	if err != nil || !neq {
		t.Errorf("Expected NotEqual true, got %v, err: %v", neq, err)
	}
}
func TestListLabelledControlArray_ToJSONAndFromJSON(t *testing.T) {
	l7, err := New(fixtureListData())
	if err != nil {
		t.Fatalf("New for ToJSON failed: %v", err)
	}
	defer l7.Close()
	jsonStr, err := l7.ToJSON()
	if err != nil {
		t.Fatalf("ToJSON failed: %v", err)
	}
	l8, err := FromJSON(jsonStr)
	if err != nil {
		t.Fatalf("FromJSON failed: %v", err)
	}
	defer l8.Close()
	items, err := l8.Items()
	if err != nil {
		t.Fatalf("Items failed: %v", err)
	}
	data := fixtureListData()
	if !eqSlice(items, data) {
		t.Errorf("Expected %v, got %v", data, items)
	}
}
func TestListLabelledControlArray_ContainsAndIndex(t *testing.T) {
	l6, err := New(fixtureListData())
	if err != nil {
		t.Fatalf("New for contains/index failed: %v", err)
	}
	defer l6.Close()
	ok, err := l6.Contains(defaultListData[1])
	if err != nil || !ok {
		t.Errorf("Expected Contains(%v) true, got %v, err: %v", defaultListData[1], ok, err)
	}
	idx, err := l6.Index(defaultListData[1])
	if err != nil || idx != 1 {
		t.Errorf("Expected Index(%v) == 1, got %d, err: %v", defaultListData[1], idx, err)
	}
}
func TestListLabelledControlArray_CAPIHandle(t *testing.T) {
	l, err := New(defaultListData)
	if err != nil {
		t.Fatalf("New failed: %v", err)
	}
	defer l.Close()
	ptr, err := l.CAPIHandle()
  if err != nil {
      t.Errorf("CAPIHandle failed to access capi")
  }
	if ptr == nil {
		t.Errorf("CAPIHandle returned nil")
	}
}
func TestListLabelledControlArray_FromCAPI(t *testing.T) {
	h, err := FromCAPI(nil)
	if err == nil || h != nil {
		t.Errorf("FromCAPI(nil) should error and return nil")
	}
}
func TestListLabelledControlArray_CloseTwice(t *testing.T) {
	l, err := New(defaultListData)
	if err != nil {
		t.Fatalf("New failed: %v", err)
	}
	err = l.Close()
	if err != nil {
		t.Errorf("First close should succeed, got %v", err)
	}
	err = l.Close()
	if err == nil {
		t.Errorf("Second close should error")
	}
}
