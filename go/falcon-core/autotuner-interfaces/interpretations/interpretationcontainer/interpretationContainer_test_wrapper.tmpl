// Code generated by go generate; DO NOT EDIT.
package {{.Package}}

import (
	"testing"
  "github.com/falcon-autotuning/falcon-core-libs/go/falcon-core/generic/{{.MapGoType}}"
  "github.com/falcon-autotuning/falcon-core-libs/go/falcon-core/generic/listinterpretationcontext"
  "github.com/falcon-autotuning/falcon-core-libs/go/falcon-core/generic/{{.ListValueGoType}}"
  "github.com/falcon-autotuning/falcon-core-libs/go/falcon-core/generic/{{.ListPairGoType}}"
  "github.com/falcon-autotuning/falcon-core-libs/go/falcon-core/autotuner-interfaces/interpretations/interpretationcontext"
  "github.com/falcon-autotuning/falcon-core-libs/go/falcon-core/generic/listconnection"
  "github.com/falcon-autotuning/falcon-core-libs/go/falcon-core/physics/device-structures/connections"
  "github.com/falcon-autotuning/falcon-core-libs/go/falcon-core/physics/device-structures/connection"
  "github.com/falcon-autotuning/falcon-core-libs/go/falcon-core/physics/units/symbolunit"
	{{.OptionalImport}}
)

// ---- Consolidated test variables ----
var (
	testMapHandle           *{{.MapGoType}}.Handle
	testConnection          *connection.Handle
	testConnections         *connections.Handle
	testListConnectionIndep *listconnection.Handle
	testListConnectionDep   *listconnection.Handle
	testInterpretationCtx   *interpretationcontext.Handle
	testInterpretationCtx2  *interpretationcontext.Handle
	testValue               {{.GoValueType}}
	testValue2              {{.GoValueType}}
	testOtherValue          {{.GoValueType}}
	testJSON                string
	testListPair            *{{.ListPairGoType}}.Handle
	testListValue           *{{.ListValueGoType}}.Handle
	testListContext         *listinterpretationcontext.Handle
	testSymbolUnit          *symbolunit.Handle
	testErr                 error
)

// ---- Helper functions ----
func setupHandles() {
	// Setup all required handles and values for tests.
	// These should be replaced with valid objects for your context.
	// Example:
	// testMapHandle, _ = {{.MapGoType}}.New(...)
	// testConnection, _ = connection.New(...)
	// testInterpretationCtx, _ = interpretationcontext.New(...)
	// testValue = ...
	// testJSON = ...
}

func eqValue(a, b {{.GoValueType}}) bool {
	{{if .ElemIsPrimitive}}
	return a == b
	{{else if .ElemIsString}}
	return a == b
	{{else}}
	eq, err := a.Equal(b)
	return err == nil && eq
	{{end}}
}

// ---- Tests ----

func TestNewAndCAPIHandle(t *testing.T) {
	setupHandles()
	h, err := New(testMapHandle)
	if err != nil {
		t.Fatalf("New failed: %v", err)
	}
	defer h.Close()
	ptr:= h.CAPIHandle()
	if ptr == nil {
		t.Errorf("CAPIHandle returned nil")
	}
	// Closed handle branch
	h.Close()
}


func TestCloseTwice(t *testing.T) {
	setupHandles()
	h, err := New(testMapHandle)
	if err != nil {
		t.Fatalf("New failed: %v", err)
	}
	err = h.Close()
	if err != nil {
		t.Errorf("First close should succeed, got %v", err)
	}
	err = h.Close()
	if err == nil {
		t.Errorf("Second close should error")
	}
}

func TestUnit(t *testing.T) {
	setupHandles()
	h, _ := New(testMapHandle)
	defer h.Close()
	u, err := h.Unit()
	if err != nil {
		t.Errorf("Unit failed: %v", err)
	}
	if u == nil {
		t.Errorf("Unit returned nil")
	}
	h.Close()
	u, err = h.Unit()
	if err == nil || u != nil {
		t.Errorf("Unit should error and return nil on closed handle")
	}
}

func TestSelectByConnection(t *testing.T) {
	setupHandles()
	h, _ := New(testMapHandle)
	defer h.Close()
	c, err := h.SelectByConnection(testConnection)
	if err != nil {
		t.Errorf("SelectByConnection failed: %v", err)
	}
	if c == nil {
		t.Errorf("SelectByConnection returned nil")
	}
	h.Close()
	c, err = h.SelectByConnection(testConnection)
	if err == nil || c != nil {
		t.Errorf("SelectByConnection should error and return nil on closed handle")
	}
}

func TestSelectByConnections(t *testing.T) {
	setupHandles()
	h, _ := New(testMapHandle)
	defer h.Close()
	c, err := h.SelectByConnections(testConnections)
	if err != nil {
		t.Errorf("SelectByConnections failed: %v", err)
	}
	if c == nil {
		t.Errorf("SelectByConnections returned nil")
	}
	h.Close()
	c, err = h.SelectByConnections(testConnections)
	if err == nil || c != nil {
		t.Errorf("SelectByConnections should error and return nil on closed handle")
	}
}

func TestSelectByIndependentConnection(t *testing.T) {
	setupHandles()
	h, _ := New(testMapHandle)
	defer h.Close()
	c, err := h.SelectByIndependentConnection(testConnection)
	if err != nil {
		t.Errorf("SelectByIndependentConnection failed: %v", err)
	}
	if c == nil {
		t.Errorf("SelectByIndependentConnection returned nil")
	}
	h.Close()
	c, err = h.SelectByIndependentConnection(testConnection)
	if err == nil || c != nil {
		t.Errorf("SelectByIndependentConnection should error and return nil on closed handle")
	}
}

func TestSelectByDependentConnection(t *testing.T) {
	setupHandles()
	h, _ := New(testMapHandle)
	defer h.Close()
	c, err := h.SelectByDependentConnection(testConnection)
	if err != nil {
		t.Errorf("SelectByDependentConnection failed: %v", err)
	}
	if c == nil {
		t.Errorf("SelectByDependentConnection returned nil")
	}
	h.Close()
	c, err = h.SelectByDependentConnection(testConnection)
	if err == nil || c != nil {
		t.Errorf("SelectByDependentConnection should error and return nil on closed handle")
	}
}

func TestSelectContexts(t *testing.T) {
	setupHandles()
	h, _ := New(testMapHandle)
	defer h.Close()
	c, err := h.SelectContexts(testListConnectionIndep, testListConnectionDep)
	if err != nil {
		t.Errorf("SelectContexts failed: %v", err)
	}
	if c == nil {
		t.Errorf("SelectContexts returned nil")
	}
	h.Close()
	c, err = h.SelectContexts(testListConnectionIndep, testListConnectionDep)
	if err == nil || c != nil {
		t.Errorf("SelectContexts should error and return nil on closed handle")
	}
}

func TestInsertOrAssign(t *testing.T) {
	setupHandles()
	h, _ := New(testMapHandle)
	defer h.Close()
	err := h.InsertOrAssign(testInterpretationCtx, testValue)
	if err != nil {
		t.Errorf("InsertOrAssign failed: %v", err)
	}
	h.Close()
	err = h.InsertOrAssign(testInterpretationCtx, testValue)
	if err == nil {
		t.Errorf("InsertOrAssign should error on closed handle")
	}
}

func TestInsert(t *testing.T) {
	setupHandles()
	h, _ := New(testMapHandle)
	defer h.Close()
	err := h.Insert(testInterpretationCtx, testValue)
	if err != nil {
		t.Errorf("Insert failed: %v", err)
	}
	h.Close()
	err = h.Insert(testInterpretationCtx, testValue)
	if err == nil {
		t.Errorf("Insert should error on closed handle")
	}
}

func TestAt(t *testing.T) {
	setupHandles()
	h, _ := New(testMapHandle)
	defer h.Close()
	val, err := h.At(testInterpretationCtx)
	if err != nil {
		t.Errorf("At failed: %v", err)
	}
	if !eqValue(val, testValue) {
		t.Errorf("At returned wrong value: got %v, want %v", val, testValue)
	}
	h.Close()
	val, err = h.At(testInterpretationCtx)
	if err == nil {
		t.Errorf("At should error on closed handle")
	}
}

func TestErase(t *testing.T) {
	setupHandles()
	h, _ := New(testMapHandle)
	defer h.Close()
	err := h.Erase(testInterpretationCtx)
	if err != nil {
		t.Errorf("Erase failed: %v", err)
	}
	h.Close()
	err = h.Erase(testInterpretationCtx)
	if err == nil {
		t.Errorf("Erase should error on closed handle")
	}
}

func TestSizeAndEmptyAndClear(t *testing.T) {
	setupHandles()
	h, _ := New(testMapHandle)
	defer h.Close()
	sz, err := h.Size()
	if err != nil {
		t.Errorf("Size failed: %v", err)
	}
  if sz != 2  {
    t.Errorf("Size returned wrong value: got %d, want %d", sz, 2)
  }
	empty, err := h.Empty()
	if err != nil {
		t.Errorf("Empty failed: %v", err)
	}
  if empty {
    t.Errorf("Empty returned wrong value: got %v, want %v", empty, false)
  }
	err = h.Clear()
	if err != nil {
		t.Errorf("Clear failed: %v", err)
	}
	h.Close()
	_, err = h.Size()
	if err == nil {
		t.Errorf("Size should error on closed handle")
	}
	_, err = h.Empty()
	if err == nil {
		t.Errorf("Empty should error on closed handle")
	}
	err = h.Clear()
	if err == nil {
		t.Errorf("Clear should error on closed handle")
	}
}

func TestContains(t *testing.T) {
	setupHandles()
	h, _ := New(testMapHandle)
	defer h.Close()
	ok, err := h.Contains(testInterpretationCtx)
	if err != nil {
		t.Errorf("Contains failed: %v", err)
	}
  if !ok {
      t.Errorf("Contains returned wrong value: got %v, want %v", ok, true)
  }
	h.Close()
	_, err = h.Contains(testInterpretationCtx)
	if err == nil {
		t.Errorf("Contains should error on closed handle")
	}
}

func TestKeysValuesItems(t *testing.T) {
	setupHandles()
	h, _ := New(testMapHandle)
	defer h.Close()
	keys, err := h.Keys()
	if err != nil {
		t.Errorf("Keys failed: %v", err)
	}
  size, err := keys.Size()
  if err != nil {
      t.Errorf("Keys Size failed: %v", err)
  }
  if size != 2 {
      t.Errorf("Keys returned wrong size: got %d, want %d", size, 2)
  }
	values, err := h.Values()
	if err != nil {
		t.Errorf("Values failed: %v", err)
	}
  size, err = values.Size()
  if err != nil {
      t.Errorf("Values Size failed: %v", err)
  }
  if size != 2 {
      t.Errorf("Values returned wrong size: got %d, want %d", size, 2)
  }
	items, err := h.Items()
	if err != nil {
		t.Errorf("Items failed: %v", err)
	}
  size, err = items.Size()
  if err != nil {
      t.Errorf("Items Size failed: %v", err)
  }
  if size != 2 {
      t.Errorf("Items returned wrong size: got %d, want %d", size, 2)
  }
	h.Close()
	_, err = h.Keys()
	if err == nil {
		t.Errorf("Keys should error on closed handle")
	}
	_, err = h.Values()
	if err == nil {
		t.Errorf("Values should error on closed handle")
	}
	_, err = h.Items()
	if err == nil {
		t.Errorf("Items should error on closed handle")
	}
}

func TestEqualNotEqual(t *testing.T) {
	setupHandles()
	a, _ := New(testMapHandle)
	defer a.Close()
	b, _ := New(testMapHandle)
	defer b.Close()
	eq, err := a.Equal(b)
	if err != nil {
		t.Errorf("Equal failed: %v", err)
	}
  if !eq {
      t.Errorf("Equal returned wrong value: got %v, want %v", eq, true)
  }
	neq, err := a.NotEqual(b)
	if err != nil {
		t.Errorf("NotEqual failed: %v", err)
	}
  if neq {
      t.Errorf("NotEqual returned wrong value: got %v, want %v", neq, false)
  }
	// nil branch
	eq, err = a.Equal(nil)
	if err == nil {
		t.Errorf("Equal should error when other is nil")
	}
	neq, err = a.NotEqual(nil)
	if err == nil {
		t.Errorf("NotEqual should error when other is nil")
	}
	// closed branch
	b.Close()
	_, err = a.Equal(b)
	if err == nil {
		t.Errorf("Equal should error when other is closed")
	}
	_, err = a.NotEqual(b)
	if err == nil {
		t.Errorf("NotEqual should error when other is closed")
	}
	a.Close()
	eq, err = a.Equal(b)
	if err == nil {
		t.Errorf("Equal should error when self is closed")
	}
	neq, err = a.NotEqual(b)
	if err == nil {
		t.Errorf("NotEqual should error when self is closed")
	}
}

func TestToJSONFromJSON(t *testing.T) {
	setupHandles()
	h, _ := New(testMapHandle)
	defer h.Close()
	jsonStr, err := h.ToJSON()
	if err != nil {
		t.Errorf("ToJSON failed: %v", err)
	}
	h.Close()
	_, err = h.ToJSON()
	if err == nil {
		t.Errorf("ToJSON should error on closed handle")
	}
	// FromJSON
	h2, err := FromJSON(jsonStr)
	if err != nil {
		t.Errorf("FromJSON failed: %v", err)
	}
	if h2 == nil {
		t.Errorf("FromJSON returned nil")
	}
}
