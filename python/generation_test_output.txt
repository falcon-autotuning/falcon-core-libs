### Generated PXD ###
DEBUG: Topologically sorted classes: ['Impedances', 'VoltageConstraints', 'MapGnameGroup', 'Connections', 'String', 'Config']
from libc.stddef cimport size_t
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint8_t, uint16_t, uint32_t, uint64_t

cdef extern from "falcon_core/generic/String_c_api.h":
    ctypedef struct string:
        const char* raw
        size_t length
    ctypedef string* StringHandle

ctypedef void* ConfigHandle
ctypedef void* ConnectionsHandle
ctypedef void* MapGnameGroupHandle
ctypedef void* ImpedancesHandle
ctypedef void* VoltageConstraintsHandle

# Impedances
cdef extern from "falcon_core/.../Impedances_c_api.h":

# VoltageConstraints
cdef extern from "falcon_core/.../VoltageConstraints_c_api.h":

# MapGnameGroup
cdef extern from "falcon_core/.../MapGnameGroup_c_api.h":

# Connections
cdef extern from "falcon_core/.../Connections_c_api.h":

# String
cdef extern from "falcon_core/.../String_c_api.h":

# Config
cdef extern from "falcon_core/.../Config_c_api.h":
    ConfigHandle Config_create(ConnectionsHandle screening_gates, ConnectionsHandle plunger_gates, ConnectionsHandle ohmics, ConnectionsHandle barrier_gates, ConnectionsHandle reservoir_gates, MapGnameGroupHandle groups, ImpedancesHandle wiring_DC, VoltageConstraintsHandle constraints)
    ConfigHandle Config_from_json_string(StringHandle json)
    void Config_destroy(ConfigHandle handle)
    StringHandle Config_to_json_string(ConfigHandle handle)
    int Config_num_unique_channels(ConfigHandle handle)
    VoltageConstraintsHandle Config_voltage_constraints(ConfigHandle handle)
    void Config_set_name(ConfigHandle handle, StringHandle name)
    StringHandle Config_get_name(ConfigHandle handle)
    int Config_get_size(ConfigHandle handle)
    void Config_at(ConfigHandle handle, int index)


### Generated PYX for Config ###
cimport _c_api
from cpython.bytes cimport PyBytes_FromStringAndSize
from libc.stddef cimport size_t
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint8_t, uint16_t, uint32_t, uint64_t
from libcpp cimport bool
from .connections cimport Connections, _connections_from_capi
from .impedances cimport Impedances, _impedances_from_capi
from .map_gname_group cimport MapGnameGroup, _map_gname_group_from_capi
from .voltage_constraints cimport VoltageConstraints, _voltage_constraints_from_capi

cdef class Config:
    def __cinit__(self):
        self.handle = <_c_api.ConfigHandle>0
        self.owned = False

    def __dealloc__(self):
        if self.handle != <_c_api.ConfigHandle>0 and self.owned:
            _c_api.Config_destroy(self.handle)
        self.handle = <_c_api.ConfigHandle>0


    @classmethod
    def new(cls, Connections screening_gates, Connections plunger_gates, Connections ohmics, Connections barrier_gates, Connections reservoir_gates, MapGnameGroup groups, Impedances wiring_DC, VoltageConstraints constraints):
        cdef _c_api.ConfigHandle h
        h = _c_api.Config_create(screening_gates.handle if screening_gates is not None else <_c_api.ConnectionsHandle>0, plunger_gates.handle if plunger_gates is not None else <_c_api.ConnectionsHandle>0, ohmics.handle if ohmics is not None else <_c_api.ConnectionsHandle>0, barrier_gates.handle if barrier_gates is not None else <_c_api.ConnectionsHandle>0, reservoir_gates.handle if reservoir_gates is not None else <_c_api.ConnectionsHandle>0, groups.handle if groups is not None else <_c_api.MapGnameGroupHandle>0, wiring_DC.handle if wiring_DC is not None else <_c_api.ImpedancesHandle>0, constraints.handle if constraints is not None else <_c_api.VoltageConstraintsHandle>0)
        if h == <_c_api.ConfigHandle>0:
            raise MemoryError("Failed to create Config")
        cdef Config obj = <Config>cls.__new__(cls)
        obj.handle = h
        obj.owned = True
        return obj

    @classmethod
    def from_json(cls, str json):
        cdef bytes b_json = json.encode("utf-8")
        cdef _c_api.StringHandle s_json = _c_api.String_create(b_json, len(b_json))
        cdef _c_api.ConfigHandle h
        try:
            h = _c_api.Config_from_json_string(s_json)
        finally:
            _c_api.String_destroy(s_json)
        if h == <_c_api.ConfigHandle>0:
            raise MemoryError("Failed to create Config")
        cdef Config obj = <Config>cls.__new__(cls)
        obj.handle = h
        obj.owned = True
        return obj

    def to_json(self, ):
        cdef _c_api.StringHandle s_ret
        s_ret = _c_api.Config_to_json_string(self.handle)
        if s_ret == <_c_api.StringHandle>0:
            return ""
        try:
            return PyBytes_FromStringAndSize(s_ret.raw, s_ret.length).decode("utf-8")
        finally:
            _c_api.String_destroy(s_ret)

    def num_unique_channels(self, ):
        return _c_api.Config_num_unique_channels(self.handle)

    @property
    def voltage_constraints(self):
        cdef _c_api.VoltageConstraintsHandle h_ret = _c_api.Config_voltage_constraints(self.handle)
        if h_ret == <_c_api.VoltageConstraintsHandle>0:
            return None
        return _voltage_constraints_from_capi(h_ret, owned=True)

    @name.setter
    def name(self, str name):
        cdef bytes b_name = name.encode("utf-8")
        cdef _c_api.StringHandle s_name = _c_api.String_create(b_name, len(b_name))
        _c_api.Config_set_name(self.handle, s_name)
        _c_api.String_destroy(s_name)

    @property
    def name(self):
        cdef _c_api.StringHandle s_ret
        s_ret = _c_api.Config_get_name(self.handle)
        if s_ret == <_c_api.StringHandle>0:
            return ""
        try:
            return PyBytes_FromStringAndSize(s_ret.raw, s_ret.length).decode("utf-8")
        finally:
            _c_api.String_destroy(s_ret)

    @property
    def size(self):
        return _c_api.Config_get_size(self.handle)

    def at(self, int index):
        _c_api.Config_at(self.handle, index)

    def __len__(self):
        return self.size

    def __getitem__(self, key):
        ret = self.at(key)
        if ret is None:
            raise IndexError(f"{key} not found in {self.__class__.__name__}")
        return ret

    def __iter__(self):
        for i in range(len(self)):
            yield self[i]

    def __repr__(self):
        return f"{self.__class__.__name__}({self.to_json()})"

    def __str__(self):
        return self.to_json()

cdef Config _config_from_capi(_c_api.ConfigHandle h, bint owned=True):
    if h == <_c_api.ConfigHandle>0:
        return None
    cdef Config obj = Config.__new__(Config)
    obj.handle = h
    obj.owned = owned
    return obj


### Generated PYX for Connections ###
cimport _c_api
from cpython.bytes cimport PyBytes_FromStringAndSize
from libc.stddef cimport size_t
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint8_t, uint16_t, uint32_t, uint64_t
from libcpp cimport bool

cdef class Connections:
    def __cinit__(self):
        self.handle = <_c_api.ConnectionsHandle>0
        self.owned = False

    def __dealloc__(self):
        if self.handle != <_c_api.ConnectionsHandle>0 and self.owned:
            pass
        self.handle = <_c_api.ConnectionsHandle>0


cdef Connections _connections_from_capi(_c_api.ConnectionsHandle h, bint owned=True):
    if h == <_c_api.ConnectionsHandle>0:
        return None
    cdef Connections obj = Connections.__new__(Connections)
    obj.handle = h
    obj.owned = owned
    return obj


### Generated PYX for MapGnameGroup ###
cimport _c_api
from cpython.bytes cimport PyBytes_FromStringAndSize
from libc.stddef cimport size_t
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint8_t, uint16_t, uint32_t, uint64_t
from libcpp cimport bool

cdef class MapGnameGroup:
    def __cinit__(self):
        self.handle = <_c_api.MapGnameGroupHandle>0
        self.owned = False

    def __dealloc__(self):
        if self.handle != <_c_api.MapGnameGroupHandle>0 and self.owned:
            pass
        self.handle = <_c_api.MapGnameGroupHandle>0


cdef MapGnameGroup _map_gname_group_from_capi(_c_api.MapGnameGroupHandle h, bint owned=True):
    if h == <_c_api.MapGnameGroupHandle>0:
        return None
    cdef MapGnameGroup obj = MapGnameGroup.__new__(MapGnameGroup)
    obj.handle = h
    obj.owned = owned
    return obj


### Generated PYX for Impedances ###
cimport _c_api
from cpython.bytes cimport PyBytes_FromStringAndSize
from libc.stddef cimport size_t
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint8_t, uint16_t, uint32_t, uint64_t
from libcpp cimport bool

cdef class Impedances:
    def __cinit__(self):
        self.handle = <_c_api.ImpedancesHandle>0
        self.owned = False

    def __dealloc__(self):
        if self.handle != <_c_api.ImpedancesHandle>0 and self.owned:
            pass
        self.handle = <_c_api.ImpedancesHandle>0


cdef Impedances _impedances_from_capi(_c_api.ImpedancesHandle h, bint owned=True):
    if h == <_c_api.ImpedancesHandle>0:
        return None
    cdef Impedances obj = Impedances.__new__(Impedances)
    obj.handle = h
    obj.owned = owned
    return obj


### Generated PYX for VoltageConstraints ###
cimport _c_api
from cpython.bytes cimport PyBytes_FromStringAndSize
from libc.stddef cimport size_t
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint8_t, uint16_t, uint32_t, uint64_t
from libcpp cimport bool

cdef class VoltageConstraints:
    def __cinit__(self):
        self.handle = <_c_api.VoltageConstraintsHandle>0
        self.owned = False

    def __dealloc__(self):
        if self.handle != <_c_api.VoltageConstraintsHandle>0 and self.owned:
            pass
        self.handle = <_c_api.VoltageConstraintsHandle>0


cdef VoltageConstraints _voltage_constraints_from_capi(_c_api.VoltageConstraintsHandle h, bint owned=True):
    if h == <_c_api.VoltageConstraintsHandle>0:
        return None
    cdef VoltageConstraints obj = VoltageConstraints.__new__(VoltageConstraints)
    obj.handle = h
    obj.owned = owned
    return obj


### Generated PYX for String ###
cimport _c_api
from cpython.bytes cimport PyBytes_FromStringAndSize
from libc.stddef cimport size_t
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint8_t, uint16_t, uint32_t, uint64_t
from libcpp cimport bool

cdef class String:
    def __cinit__(self):
        self.handle = <_c_api.StringHandle>0
        self.owned = False

    def __dealloc__(self):
        if self.handle != <_c_api.StringHandle>0 and self.owned:
            pass
        self.handle = <_c_api.StringHandle>0


cdef String _string_from_capi(_c_api.StringHandle h, bint owned=True):
    if h == <_c_api.StringHandle>0:
        return None
    cdef String obj = String.__new__(String)
    obj.handle = h
    obj.owned = owned
    return obj


### Generated Registry Entries ###
# Paste these into the corresponding generic file (list.py, map.py, pair.py)

# _C_MAP_REGISTRY
('Map', '(Gname, Group)', '_CMapGnameGroup')
